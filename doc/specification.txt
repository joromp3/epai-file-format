# Extensible Package for Animated Images -- Specification

(revision 0.1 (version code 0x00) *DRAFT*) *WORK IN PROGRESS*


Author: Jasen Borisov
Date: November 2014


## Introduction

Extensible Package for Animated Images (EPAI) is a file format intended
primarily for games, graphics developers, and graphics software. It aims
to allow for maximum flexibility in implementation and use; to provide a
standard that can be adapted for a large variety of use cases common in
games and graphics applications, especially on embedded systems.

Important features of the format:
- Multiple images can be packed into one file.
- Each image can be optionally animated.
 - Full control over keyframes, to support skips and loops.
 - Control over frame properties such as duration, position, dimensions.
- Flexibility with pixel data format.
 - Mix of integer/float with varying sizes/precisions for each channel.
 - Any combination of up to 16 channels per pixel, allowing each pixel
   to carry information like alpha, depth, lighting/shading data, etc,
   alongside RGB color.
- Text metadata.
- Reserved private use space, giving the ability to extend and adapt to
  custom applications.


## Format Overview

The file is a tree of sections. Every part of the file (including the
file signature) is defined as a section. Certain section types can
contain other nested sections.


### Note on Private Use

It is part of the design goals for the format to allow it to be
adaptable to fit domain-specific needs. Therefore, there are many parts
of this specification which explicitly define values or fields reserved
for private use.

In general, files using such "private use" values are considered to be
non-standard and likely unparsable by standard implementations. The
exception to this are private use section types in the optional range,
as implementations are free to ignore optional sections (see below). Any
other minor exceptions may be noted within the specifications of the
individual section types.


### Section Types

Every section begins with a type code, which is an 8-bit unsigned
integer value.

What follows after the first byte differs for each section type.

Sections can be either mandatory or optional. This is indicated by the
most significant bit of the section type code, as follows:

- MSB 1 (range 0x80-0xFF) indicates a mandatory section.
- MSB 0 (range 0x00-0x7F) indicates an optional section.

Mandatory section types are essential to the file and must be parsed in
order to display an adequate representation of the encoded information.

Optional section types contain information which is not essential. An
adequate minimal representation of the encoded information can be
produced by a decoding implementation even if these section types are
ignored.

All optional sections must contain a 32-bit unsigned integer value
immediately after the section type value, to indicate the length of the
remainder of the section. This is to permit implementations to easily
skip the section.

Section types in the ranges 0x00-0x3F and 0x80-0xBF are reserved for use
by the standard. Implementations must not define custom private use
sections with type codes in those ranges.

Section types in the ranges 0x40-0x7F and 0xC0-0xFF are reserved for
private use, and may be used for any implementation-specific purpose.
These values will never be used by the official standard.

All mandatory sections in an input file must be parsed. All
implementations must implement support for all mandatory section types
defined in this document. Mandatory sections not defined in this
document are allowed in files as long as their type code falls in the
private use range. Implementations must refuse to parse input files
containing mandatory sections from the private use range which they do
not support, or files which contain mandatory sections which are neither
defined in this document nor fall in the defined private use range.

Implementations are not required to implement support for any optional
section types, including ones defined in this document. Implementations
are allowed to ignore optional sections in a file for any reason. When
modifying existing files, implementations must remove any optional
sections which they do not support.

Certain section types may contain references to other sections defined
before them, for various reasons. These references point to a specific
section type, and take the form of the index of the section in the order
of appearance in the file. Sections may only refer to other sections
which appear before them in a file; references pointing to sections
appearing later in the file stream are not allowed. This reference
pointer system prevents duplicate data in a file.

List of all section types:

0x00		zero padding
0x01		checksum
0x02		text metadata
0x03		compressed text
0x04		frame
0x05		gamma correction
0x06		spritesheet data
0x07-0x3F	(reserved for future standard use)
0x40-0x7F	(reserved for private use)
0x80		file signature
0x81		pixel format
0x82		palette
0x83		image
0x84		keyframe
0x85-0xBF	(reserved for future standard use)
0xC0-0xFF	(reserved for private use)


## Standard Mandatory Sections

Here follow the exact specifications for each mandatory section type
defined by this standard.


### Section 0x80: File Signature

The file signature is logically considered the parent of all other
sections. It must appear exactly once, at the very beginning of every
file. It ends implicitly when the file ends.

The file signature header has the following syntax:

	Byte:	0	1	2	3
	Hex:	0x80	0x45	0x50	0x41

	Byte:	4	5	6	7
	Hex:	0x49	0x0D	0x0A	0x0A

	Byte:	8	8/9 (16-bit unsigned integer)
	Hex:	0x00	0xAF00

	Total length: 11 bytes.

Byte 0 is the section type. It is non-ASCII and prevents the file from
being misidentified as plain text.

Bytes 1-4 spell out "EPAI" in ASCII, serving as a human-readable
identification of the file format.

Bytes 5-6 are a DOS CRLF line ending. They allow to check if the file
has been corrupted by DOS->UNIX line ending conversion.

Byte 7 is a UNIX LF line ending. It allows to check if the file has been
corrupted by UNIX->DOS line ending conversion.

Byte 8 is the version of the format specification that the file follows.

Bytes 9-10 are a single 16-bit unsigned integer value which serves as an
endian marker, to indicate endianness of any multi-byte values that
appear later in the file. The zero byte in the endian marker can be used
to detect a type of file corruption where zero bytes are removed during
transmission.

The file must be encoded in either big or little endian; no other endian
formats (such as PDP/mixed endian) are allowed.

The implementation must do endian conversion for all multi-byte values
in the file if the endian marker in the file signature indicates an
endianness that does not match the one of the decoding machine.

After the header specified above, immediately follow all other sections
of the file. Logically, all other sections can be considered as
contained within a global file signature section which ends at the end
of the file.


### Section 0x81: Pixel Format

A section of this type is used to define a pixel format to be used for
encoding pixel data in other sections later in the file.

At least one pixel format section must be present in every file. The
maximum number of pixel format sections in one file is 256.

This section type cannot be contained in any section other than 0x80
(File Signature). This section type cannot contain any child sections.

Pixel format sections have the following syntax:

	Size	Value
	1 byte	0x81
	1 byte	number of channels
	1 byte	channel #0
	...	... more channels ...

Byte 0 is the section type code.

Byte 1 is the number of channels in the pixel format. The maximum number
of channels in a pixel format is 16, as there are only 16 channel type
values. More on that below.

After that follow the channel format definitions, one byte each. They
are encoded as follows:

	0123 4567	(most significant bit is labeled 0)
	^--- ^---
	DT   CT

The channel format definitions are composed of two values, 4 bits each,
a Data Type and a Channel Type.

The data type value indicates the binary format for the channel data. It
can have one of the following values:

	Value	Meaning
	0000	4-bit unsigned integer
	0001	8-bit unsigned integer
	0010	16-bit unsigned integer
	0011	24-bit unsigned integer
	0100	32-bit unsigned integer
	0101	reserved for future standard use
	0110	private use
	0111	private use
	1000	16-bit half float
	1001	32-bit single float
	1010	64-bit double float
	1011	reserved for future standard use
	1100	private use
	1101	private use
	1110	private use
	1111	private use

The channel type value indicates the intended meaning of the information
encoded in the channel. It can have one of the following values:

	Value	Meaning
	0000	gray / color index / private use ; see below
	0001	red
	0010	green
	0011	blue
	0100	alpha
	0101	depth
	0110	mask / stencil
	0111	private use
	1000	? x coordinate / normal
	1001	? y coordinate / normal
	1010	? z coordinate / normal
	1011	? heightmap
	1100	? diffuse
	1101	? specularity
	1110	private use
	1111	private use

0000 is a special multi-purpose value. If none of the RGB channel types
exist in the same pixel format section, it is interpreted as either
grayscale or color index, depending on whether or not there exists a
palette section elsewhere in the file which is associated with the pixel
format section (see the palette section specification). If any of the
RGB channels are defined, 0000 becomes a private use value.

There are three (or four if counting 0000) private use values available
to implementations for custom needs. The meanings for channel types
>=1000 (marked with '?' above) are only suggested (as those are
relatively common for graphics in games). If the standard three private
use values are insufficient for the needs of an implementation, the
values marked with '?' above may also be used for private use. The '?'
above indicates that those meanings are to be treated as a convention as
opposed to a requirement.

More than one channel definition with the same 4-bit channel type value
is not allowed within the same pixel format section.

Note that none of the above channel types are required in a pixel
format. Every pixel format must contain at least one channel, but it can
be of any type. A pixel format with no color channels is perfectly
valid, for example.


### Section 0x82: Palette

A section of this type defines a palette to be used with pixel formats
which contain a color-index channel to be used as color information.

This section cannot contain other sections, and can only appear globally
as a child of 0x80 (File Signature).

Palette sections have the following syntax:

	Size	Value
	1 byte	0x82
	1 byte	number of associated pixel formats
	1 byte	reference to pixel format section
	...	... more references ...
	1 byte	number of colors
	3 bytes	color encoded in 24-bit (8 bpc) RGB
	...	... more colors ...

Byte 0 is the section type code.

Byte 1 is the number of pixel format sections which use this section as
their palette data. This number can be zero, which, while likely to be
useless practically (resulting in an extraneous palette section), is
considered valid.

After that follow references to all the pixel format sections which use
this section as their palette data. All of these associated pixel
formats must contain a channel of type 0000 and no channels with types
in the range 0001-0011 (RGB). The 0000 channel can only have a data type
in the range 0000-0001 (unsigned integer with either 4 or 8 bits size).

After that follows an 8-bit unsigned integer which represents the number
of colors in the palette minus one. Therefore, the maximum number of
colors a palette can contain in 256 and the minimum is one. However, the
number of colors in the palette is completely independent from the size
of the color index channel in the associated pixel formats. Extra colors
are simply ignored, and missing colors must be interpreted as fully
transparent.

After that follow the definitions of all the colors in the palette, each
taking 1 byte for red, 1 byte for green, and 1 byte for blue, in that
order.


### Section 0x83: Image

// TODO


### Section 0x84: Keyframe

// TODO


## Standard Optional Sections

Here follow the exact specifications for each optional section type
defined by this standard.


### Section 0x00: Zero Padding

This section type allows padding to be added to files if they need to be
of a certain size.

This is the only way to add padding legally; anything else will likely
confuse decoding implementations (as any value outside of a section is
considered the beginning of a new section). The minimum number of bytes
of padding that can be inserted into a file is 5, as this considered an
"optional section" and therefore needs 1 byte for type code and 4 bytes
for length.

Zero padding sections have the following syntax:

	Size	Value
	1 byte	0x00
	4 bytes	length of remainder of section
	n bytes	... zeroes ...

Byte 0 is the section type code. The next 4 bytes are the standard
section length that must be present for all optional sections; in this
case, the number of zeroes following after it.

The remainder of the section must be filled with zeroes. Any other value
is considered invalid. It is recommended that implementations check the
contents of zero padding sections to ensure that they are actually
filled with zeroes.


### Section 0x01: Section Checksums

This section type allows checksums to be included in a file, to ensure
data correctness.

This section can only appear globally as a child of section type 0x80
(File Signature). It can appear at most once per file. It cannot contain
any other sections.

This section contains checksums for individual other sections
in the file. It can contain multiple checksums for the same section.
Sections are checksummed selectively; there is no restriction on how
many sections this section contains checksums for. The only section
types that checksums are allowed for are 0x03 (Compressed Text) and 0x83
(Image).

The checksums section has the following syntax:

	Size	Value
	1 byte	0x01
	4 bytes	length of remainder of section
	- 1 byte	referenced section type
	- 1 byte	referenced section index
	- n bytes	null terminated string indicating checksum type
	- 1 byte	length of checksum
	- m bytes	checksum as null-terminated hex string
	...	... more checksum records ...

Byte 0 is the section type code.

Bytes 1-4 are the standard optional section length.

After that follow the checksum records. Every checksum record is
composed of multiple values (all the values that begin with a dash above
are part of each record).

The first byte in each record is the type code of the section that the
checksum is for. The second byte is the index/reference to the section
that the checksum is for.

The next part of the record is a null-terminated string indicating the
checksum type/algorithm. It can only contain characters A-Z,0-9.
Examples: "MD5", "SHA256", "CRC32".

It is recommended that implementations support at least the MD5
algorithm and the SHA family of algorithms. Implementations should
quietly ignore checksums that they do not support.

After the type string follows 1 byte indicating the length of the
checksum string.

Then follows the checksum, as a null-terminated ASCII hexadecimal
string.

For compressed text sections, checksum the entire section including type
code and length. For images, prepend the pixel format the image uses to
the image section, both complete with section type, etc.


### Section 0x02: Text Metadata

This section type allows text metadata to be stored. The text in
sections of this type is uncompressed, and therefore, this section type
should only be used for short pieces of textual metadata. If long
amounts of text need to be stored in the file, section type 0x03
(Compressed Text) should be used instead.

The data in this section is organized in key-value pairs. The
specification defines some conventions for common metadata keys.
However, this being an optional section, implementations are free to
parse only the ones they need (or none at all). None of the standard
keys defined below are required to be present in a text metadata
section, and implementations are allowed to add extra keys of their own.

This section type cannot contain other sections. Text metadata sections
may only appear inside sections of type 0x80 (File Signature) and 0x83
(Image). There can be only one global text metadata section. Only one
text metadata section per image is allowed. The global text metadata
section is interpreted to contain metadata about the entire archive.
Text metadata sections which appear inside images are interpreted to
contain metadata about the individual images themselves.

Text metadata sections have the following syntax:

	Size	Value
	1 byte	0x02
	4 bytes	length of remainder of section
	n bytes	null-terminated string (key)
	m bytes	null-terminated UTF-8 string (value)
	...	... more key-value pairs ...

Byte 0 is the section type code.

Bytes 1-4 form the standard optional section length.

Then follow all of the key-value pairs as null-terminated strings. Keys
can only contain characters A-Z,a-z (english alphabet letters, in
ascii), and are case-insensitive. Values are UTF-8 encoded strings and
can contain any Unicode character.

Keys must be shorter than 16 characters. Values can have a maximum
length of 256 bytes. Null-terminating byte is included in both counts,
so the real number of visible characters inside is actually one less.

Duplicate keys are not allowed. Empty strings for keys are not allowed.
Empty strings for values are legal but not recommended.

A text metadata section may contain a maximum of 256 key-value pairs.

A list of standard keys is defined, which should be used for common
metadata information when possible. They are:

Standard keys for the global text metadata section:
- "Title": short (one-line) description of the whole archive.
- "Description": possibly longer description of the whole archive.
- "Encoder": the name of the software used to encode the file.
- "Version": the version of the whole image package.
- "Comment": miscellaneous comment.

Standard keys for per-image text metadata sections:
- "Title" = short (one-line) description of the specific image.
- "Description" = possibly longer description of the specific image.
- "Author" = the name of the image's creator.
- "Software" = the software used to create the content (not encoder!).
- "Copyright": copyright notice.
- "ContentVersion": revision/version number for the image content.
- "Comment" = miscellaneous comment.

The per-image "Author", "Software", and "Copyright" fields can be
specified globally in the global text metadata section, in which case
their values will be interpreted as applying to all images in the
archive which do not specify their own values. This allows to avoid
repetition in an archive in which most or all images would otherwise
have the same values for these fields.

It must be noted that the per-image "Software" field is intended for the
application that the image's creator used to create the content of the
image, which is often different from the software that was used to
encode the file. The global "Encoder" field should be used for the
software that was used to encode the actual file.


### Section 0x03: Compressed Text

// TODO


### Section 0x04: Frame

// TODO


### Section 0x05: Gamma Correction Information

// TODO


### Section 0x06: Spritesheet Data

// TODO


## Rationale and Remarks on Design

Some explanations, personal remarks, and notes about the various design
decisions which had to be made while designing the EPAI format, such as
exactly why certain features were added/omitted from the specification.


### Design Goals

The intended use of this file format is in 2D and 3D games and graphics
development. The format is designed with the following goals in mind:

1. Define a standard for functionality which is commonly needed by the
   target audience of the format.
2. Ease of extensibility and adaptability to custom needs.
3. Ease of implementation and simplicity.
4. Optimizeable for embedded and low-spec systems.

The PNG file format was a major inspiration for a lot of the design
aspects of EPAI.


### Endianness

Both big and little endian encodings are supported to allow the data to
be matched and optimized for decoding on a variety of systems.

Mixed endian encodings are not supported, because they would increase
the complexity unnecessarily and make implementation harder. Very few
modern machine architectures use mixed endian anyway.


### Data Formats for Channels

// TODO explain choice of integer and float formats.



# Extensible Package for Animated Images -- Specification

(revision 0.1 *DRAFT*) *WORK IN PROGRESS*


Author: Jasen Borisov
Date: November 2014


## Introduction

Extensible Package for Animated Images (EPAI) is a file format intended
primarily for games, graphics developers, and graphics software. It aims
to allow for maximum flexibility in implementation and use; to provide a
standard that can be adapted for a large variety of use cases common in
games and graphics applications, especially on embedded systems.

Important features of the format:
- Multiple images can be packed into one file.
- Each image can be optionally animated.
 - Full control over keyframes, to support skips and loops.
 - Control over frame properties such as duration, position, dimensions.
- Flexibility with pixel data format.
 - Mix of integer/float with varying sizes/precisions for each channel.
 - Any combination of up to 16 channels per pixel, allowing each pixel
   to carry information like alpha, depth, lighting/shading data, etc,
   alongside RGB color.
- Text metadata.
- Reserved private use space, giving the ability to extend and adapt to
  custom applications.


## Format Overview

The file is a tree of sections. Every part of the file (including the
file signature) is defined as a section. Certain section types can
contain other nested sections.


### Note on Private Use

It is part of the design goals for the format to allow it to be
adaptable to fit domain-specific needs. Therefore, there are many parts
of this specification which explicitly define values or fields reserved
for private use.

In general, files using such "private use" values are considered to be
non-standard and likely unparsable by standard implementations. The
exception to this are private use section types in the optional range,
as implementations are free to ignore optional sections (see below). Any
other minor exceptions may be noted within the specifications of the
individual section types.


### Section Types

Every section begins with a type code, which is an 8-bit unsigned
integer value.

What follows after the first byte differs for each section type.

Sections can be either mandatory or optional. This is indicated by the
most significant bit of the section type code, as follows:

- MSB 1 (range 0x80-0xFF) indicates a mandatory section.
- MSB 0 (range 0x00-0x7F) indicates an optional section.

Mandatory section types are essential to the file and must be parsed in
order to display an adequate representation of the encoded information.

Optional section types contain information which is not essential. An
adequate minimal representation of the encoded information can be
produced by a decoding implementation even if these section types are
ignored.

All optional sections must contain a 32-bit unsigned integer value
immediately after the section type value, to indicate the length of the
remainder of the section. This is to permit implementations to easily
skip the section.

Section types in the ranges 0x00-0x3F and 0x80-0xBF are reserved for use
by the standard. Implementations must not define custom private use
sections with type codes in those ranges.

Section types in the ranges 0x40-0x7F and 0xC0-0xFF are reserved for
private use, and may be used for any implementation-specific purpose.
These values will never be used by the official standard.

All mandatory sections in an input file must be parsed. All
implementations must implement support for all mandatory section types
defined in this document. Mandatory sections not defined in this
document are allowed in files as long as their type code falls in the
private use range. Implementations must refuse to parse input files
containing mandatory sections from the private use range which they do
not support, or files which contain mandatory sections which are neither
defined in this document nor fall in the defined private use range.

Implementations are not required to implement support for any optional
section types, including ones defined in this document. Implementations
are allowed to ignore optional sections in a file for any reason. When
modifying existing files, implementations must remove any optional
sections which they do not support.

Certain section types may contain references to other sections defined
before them, for various reasons. These references point to a specific
section type, and take the form of the index of the section in the order
of appearance in the file. Sections may only refer to other sections
which appear before them in a file; references pointing to sections
appearing later in the file stream are not allowed. This reference
pointer system prevents duplicate data in a file.

List of all section types:

0x00		zero padding
0x01		checksum
0x02		text metadata
0x03		compressed text
0x04		frame
0x05		gamma correction
0x06		spritesheet data
0x07-0x3F	(reserved for future standard use)
0x40-0x7F	(reserved for private use)
0x80		pixel format
0x81		palette
0x82		image
0x83		keyframe
0x84		file signature
0x85-0xBF	(reserved for future standard use)
0xC0-0xFF	(reserved for private use)


## Standard Mandatory Sections

Here follow the exact specifications for each mandatory section type
defined by this standard.


### Section 0x84: File Signature

The file signature is logically considered the parent of all other
sections. It must appear exactly once, at the very beginning of every
file. It ends implicitly when the file ends.

The file signature header has the following syntax:

	Byte:	0	1	2	3
	Hex:	0x84	0x45	0x50	0x41

	Byte:	4	5	6	7
	Hex:	0x49	0x0D	0x0A	0x0A

	Byte:	8/9 (16-bit unsigned integer)
	Hex:	0x2A00

	Total length: 10 bytes.

Byte 0 is the section type. It is non-ASCII and prevents the file from
being misidentified as plain text.

Bytes 1-4 spell out "EPAI" in ASCII, serving as a human-readable
identification of the file format.

Bytes 5-6 are a DOS CRLF line ending. They allow to check if the file
has been corrupted by DOS->UNIX line ending conversion.

Byte 7 is a UNIX LF line ending. It allows to check if the file has been
corrupted by UNIX->DOS line ending conversion.

Bytes 8-9 are a single 16-bit unsigned integer value which serves as an
endian marker, to indicate endianness of any multi-bytes values that
appear later in the file. The zero byte in the endian marker can be used
to detect a type of file corruption where zero bytes are removed during
transmission.

The file must be encoded in either big or little endian; no other endian
formats (such as PDP/mixed endian) are allowed.

The implementation must do endian conversion for all multi-byte values
in the file if the endian marker in the file signature indicates an
endianness that does not match the one of the decoding machine.

After the header specified above, immediately follow all other sections
of the file. Logically, all other sections can be considered as
contained within a global file signature section which ends at the end
of the file.


### Section 0x80: Pixel Format

A section of this type is used to define a pixel format to be used for
encoding pixel data in other sections later in the file.

At least one pixel format section must be present in every file. The
maximum number of pixel format sections in one file is 256.

This section type cannot be contained in any section other than 0x84
(File Signature). This section type cannot contain any child sections.

Pixel format sections have the following syntax:

	Size	Value
	1 byte	0x80
	1 byte	number of channels
	1 byte	channel #0
	...	... more channels ...

Byte 0 is the section type code.

Byte 1 is the number of channels in the pixel format. The maximum number
of channels in a pixel format is 16, as there are only 16 channel type
values. More on that below.

After that follow the channel format definitions, one byte each. They
are encoded as follows:

	0123 4567	(most significant bit is labeled 0)
	^--- ^---
	DT   CT

The channel format definitions are composed of two values, 4 bits each,
a Data Type and a Channel Type.

The data type value indicates the binary format for the channel data. It
can have one of the following values:

	Value	Meaning
	0000	1-bit unsigned integer
	0001	2-bit unsigned integer
	0010	4-bit unsigned integer
	0011	8-bit unsigned integer
	0100	16-bit unsigned integer
	0101	24-bit unsigned integer
	0110	32-bit unsigned integer
	0111	private use
	1000	16-bit half float
	1001	32-bit single float
	1010	64-bit double float
	1011	reserved for future standard use
	1100	reserved for future standard use
	1101	private use
	1110	private use
	1111	private use

The channel type value indicates the intended meaning of the information
encoded in the channel. It can have one of the following values:

	Value	Meaning
	0000	gray / color index / private use ; see below
	0001	red
	0010	green
	0011	blue
	0100	alpha
	0101	depth
	0110	mask / stencil
	0111	private use
	1000	? x coordinate / normal
	1001	? y coordinate / normal
	1010	? z coordinate / normal
	1011	? heightmap
	1100	? diffuse
	1101	? specularity
	1110	private use
	1111	private use

0000 is a special multi-purpose value. If none of the RGB channel types
exist in the same pixel format section, it is interpreted as either
grayscale or color index, depending on whether or not there exists a
palette section elsewhere in the file which is associated with the pixel
format section (see the palette section specification). If any of the
RGB channels are defined, 0000 becomes a private use value.

There are three (or four if counting 0000) private use values available
to implementations for custom needs. The meanings for channel types
>=1000 (marked with '?' above) are only suggested (as those are
relatively common for graphics in games). If the standard three private
use values are insufficient for the needs of an implementation, the
values marked with '?' above may also be used for private use. The '?'
above indicates that those meanings are to be treated as a convention as
opposed to a requirement.

More than one channel definition with the same 4-bit channel type value
is not allowed within the same pixel format section.

Note that none of the above channel types are required in a pixel
format. Every pixel format must contain at least one channel, but it can
be of any type. A pixel format with no color channels is perfectly
valid, for example.


### Section 0x81: Palette

A section of this type defines a palette to be used with pixel formats
which contain a color-index channel to be used as color information.

This section cannot contain other sections, and can only appear globally
as a child of 0x84 (File Signature).

Palette sections have the following syntax:

	Size	Value
	1 byte	0x81
	1 byte	number of associated pixel formats
	1 byte	reference to pixel format section
	...	... more references ...
	1 byte	number of colors
	3 bytes	color encoded in 24-bit (8 bpc) RGB
	...	... more colors ...

Byte 0 is the section type code.

Byte 1 is the number of pixel format sections which use this section as
their palette data. This number can be zero, which, while likely to be
useless practically (resulting in an extraneous palette section), is
considered valid.

After that follow references to all the pixel format sections which use
this section as their palette data. All of these associated pixel
formats must contain a channel of type 0000 and no channels with types
in the range 0001-0011 (RGB). The 0000 channel can only have a data type
in the range 0000-0011 (unsigned integer with maximum 8 bits size).

After that follows an 8-bit unsigned integer which represents the number
of colors in the palette minus one. Therefore, the maximum number of
colors a palette can contain in 256 and the minimum is one. However, the
number of colors in the palette is completely independent from the size
of the color index channel in the associated pixel formats. Extra colors
are simply ignored, and missing colors must be interpreted as black.

After that follow the definitions of all the colors in the palette, each
taking 1 byte for red, 1 byte for green, and 1 byte for blue, in that
order.


### Section 0x82: Image

// TODO


### Section 0x83: Keyframe

// TODO


## Standard Optional Sections

Here follow the exact specifications for each optional section type
defined by this standard.


### Section 0x00: Zero Padding

// TODO


### Section 0x01: Checksums

// TODO


### Section 0x02: Text Metadata

// TODO


### Section 0x03: Compressed Text

// TODO


### Section 0x04: Frame

// TODO


### Section 0x05: Gamma Correction Information

// TODO


### Section 0x06: Spritesheet Data

// TODO

